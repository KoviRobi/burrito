////
// DO NOT EDIT THIS FILE
////

const std = @import("std");
const foilz = @import("src/archiver.zig");

const log = std.log;

const Builder = std.build.Builder;
const CrossTarget = std.zig.CrossTarget;
const Mode = std.builtin.Mode;
const LibExeObjStep = std.build.LibExeObjStep;

var builder: *Builder = undefined;
var target: *CrossTarget = undefined;
var mode: *Mode = undefined;

var wrapper_exe: *LibExeObjStep = undefined;

pub fn build(b: *Builder) !void {
    log.info("Zig is building an Elixir binary... âš¡", .{});

    builder = b;
    target = &builder.standardTargetOptions(.{});
    mode = &builder.standardReleaseOptions();

    // Run build steps!
    _ = try run_archiver();
    _ = try build_wrapper();

    log.info("DONE ðŸš€", .{});
}

pub fn run_archiver() !void {
    log.info("Generating and compressing release payload... ðŸ“¦", .{});

    const release_path = std.os.getenv("__BURRITO_RELEASE_PATH");
    try foilz.pack_directory(release_path.?, "./payload.foilz");

    // const compress_cmd = builder.addSystemCommand(&[_][]const u8{ "/bin/sh", "-c", "gzip -9nf payload.foilz" });
    const compress_cmd = builder.addSystemCommand(&[_][]const u8{ "/bin/sh", "-c", "xz -9ez --check=crc32 --keep payload.foilz" });
    try compress_cmd.step.make();
}

pub fn build_wrapper() !void {
    log.info("Building wrapper and embedding payload... ðŸŒ¯", .{});

    const release_name = std.os.getenv("__BURRITO_RELEASE_NAME");
    const plugin_path = std.os.getenv("__BURRITO_PLUGIN_PATH");
    const is_prod = std.os.getenv("__BURRITO_IS_PROD");

    var file = try std.fs.cwd().openFile("payload.foilz", .{});
    defer file.close();
    const uncompressed_size = try file.getEndPos();

    wrapper_exe = builder.addExecutable(release_name.?, "src/wrapper.zig");

    const exe_options = builder.addOptions();
    wrapper_exe.addOptions("build_options", exe_options);

    exe_options.addOption([]const u8, "RELEASE_NAME", release_name.?);
    exe_options.addOption(u64, "UNCOMPRESSED_SIZE", uncompressed_size);

    if (std.mem.eql(u8, is_prod.?, "1")) {
        exe_options.addOption(bool, "IS_PROD", true);
    } else {
        exe_options.addOption(bool, "IS_PROD", false);
    }

    wrapper_exe.setTarget(target.*);
    wrapper_exe.setBuildMode(mode.*);

    if (target.isWindows()) {
        wrapper_exe.addIncludeDir("src/");
    }

    // Link standard C libary to the wrapper
    wrapper_exe.linkSystemLibrary("c");

    if (plugin_path) |plugin| {
        log.info("Plugin found! {s} ðŸ”Œ", .{plugin});
        wrapper_exe.addPackagePath("burrito_plugin", plugin);
    } else {
        wrapper_exe.addPackagePath("burrito_plugin", "./_dummy_plugin.zig");
    }

    wrapper_exe.addIncludeDir("src/xz");
    wrapper_exe.addCSourceFile("src/xz/xz_crc32.c", &[0][]const u8{});
    wrapper_exe.addCSourceFile("src/xz/xz_dec_lzma2.c", &[0][]const u8{});
    wrapper_exe.addCSourceFile("src/xz/xz_dec_stream.c", &[0][]const u8{});

    wrapper_exe.install();

    const run_cmd = wrapper_exe.run();
    run_cmd.step.dependOn(builder.getInstallStep());

    const run_step = builder.step("run", "Run the app");
    run_step.dependOn(&run_cmd.step);
}
